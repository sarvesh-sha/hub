/*
 * Copyright (C) 2017-, Optio3, Inc. All Rights Reserved.
 *
 * Proprietary & Confidential Information.
 *
 * Docker Engine API
 * The Engine API is an HTTP API served by Docker Engine. It is the API the Docker client uses to communicate with the Engine, so everything the Docker client can do can be done with the API.
 *
 * OpenAPI spec version: 1.28
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.optio3.infra.docker.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.databind.JsonNode;

public class Config
{

    /**
     * The hostname to use for the container, as a valid RFC 1123 hostname.
     */
    public String                   hostname        = null;
    /**
     * The domain name to use for the container.
     */
    public String                   domainname      = null;
    /**
     * The user that commands are run as inside the container.
     */
    public String                   user            = null;
    /**
     * Whether to attach to `stdin`.
     */
    public Boolean                  attachStdin     = false;
    /**
     * Whether to attach to `stdout`.
     */
    public Boolean                  attachStdout    = true;
    /**
     * Whether to attach to `stderr`.
     */
    public Boolean                  attachStderr    = true;
    /**
     * An object mapping ports to an empty object in the form:  `{\"<port>/<tcp|udp>\": {}}`
     */
    public Map<String, EmptyObject> exposedPorts    = new HashMap<String, EmptyObject>();
    /**
     * Attach standard streams to a TTY, including `stdin` if it is not closed.
     */
    public Boolean                  tty             = false;
    /**
     * Open `stdin`
     */
    public Boolean                  openStdin       = false;
    /**
     * Close `stdin` after one attached client disconnects
     */
    public Boolean                  stdinOnce       = false;
    /**
     * A list of environment variables to set inside the container in the form `[\"VAR=value\", ...]`
     */
    public List<String>             env             = new ArrayList<String>();
    /**
     * Command to run specified as a string or an array of strings.
     */
    public List<String>             cmd             = new ArrayList<String>();
    public HealthConfig             healthcheck     = null;
    /**
     * Command is already escaped (Windows only)
     */
    public Boolean                  argsEscaped     = null;
    /**
     * The name of the image to use when creating the container
     */
    public String                   image           = null;
    /**
     * An object mapping mount point paths inside the container to empty objects.
     */
    public Map<String, JsonNode>    volumes         = new HashMap<String, JsonNode>();
    /**
     * The working directory for commands to run in.
     */
    public String                   workingDir      = null;
    /**
     * The entry point for the container as a string or an array of strings.  If the array consists of exactly one empty string (`[\"\"]`) then the entry point is reset to system default (i.e., the entry point used by docker when there is no `ENTRYPOINT` instruction in the `Dockerfile`).
     */
    public List<String>             entrypoint      = new ArrayList<String>();
    /**
     * Disable networking for the container.
     */
    public Boolean                  networkDisabled = null;
    /**
     * MAC address of the container.
     */
    public String                   macAddress      = null;
    /**
     * `ONBUILD` metadata that were defined in the image's `Dockerfile`.
     */
    public List<String>             onBuild         = new ArrayList<String>();
    /**
     * User-defined key/value metadata.
     */
    public Map<String, String>      labels          = new HashMap<String, String>();
    /**
     * Signal to stop a container as a string or unsigned integer.
     */
    public String                   stopSignal      = "SIGTERM";
    /**
     * Timeout to stop a container in seconds.
     */
    public Integer                  stopTimeout     = null;
    /**
     * Shell for when `RUN`, `CMD`, and `ENTRYPOINT` uses a shell.
     */
    public List<String>             shell           = new ArrayList<String>();

    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder();
        sb.append("class Config {\n");

        sb.append("    hostname: ")
          .append(toIndentedString(hostname))
          .append("\n");
        sb.append("    domainname: ")
          .append(toIndentedString(domainname))
          .append("\n");
        sb.append("    user: ")
          .append(toIndentedString(user))
          .append("\n");
        sb.append("    attachStdin: ")
          .append(toIndentedString(attachStdin))
          .append("\n");
        sb.append("    attachStdout: ")
          .append(toIndentedString(attachStdout))
          .append("\n");
        sb.append("    attachStderr: ")
          .append(toIndentedString(attachStderr))
          .append("\n");
        sb.append("    exposedPorts: ")
          .append(toIndentedString(exposedPorts))
          .append("\n");
        sb.append("    tty: ")
          .append(toIndentedString(tty))
          .append("\n");
        sb.append("    openStdin: ")
          .append(toIndentedString(openStdin))
          .append("\n");
        sb.append("    stdinOnce: ")
          .append(toIndentedString(stdinOnce))
          .append("\n");
        sb.append("    env: ")
          .append(toIndentedString(env))
          .append("\n");
        sb.append("    cmd: ")
          .append(toIndentedString(cmd))
          .append("\n");
        sb.append("    healthcheck: ")
          .append(toIndentedString(healthcheck))
          .append("\n");
        sb.append("    argsEscaped: ")
          .append(toIndentedString(argsEscaped))
          .append("\n");
        sb.append("    image: ")
          .append(toIndentedString(image))
          .append("\n");
        sb.append("    volumes: ")
          .append(toIndentedString(volumes))
          .append("\n");
        sb.append("    workingDir: ")
          .append(toIndentedString(workingDir))
          .append("\n");
        sb.append("    entrypoint: ")
          .append(toIndentedString(entrypoint))
          .append("\n");
        sb.append("    networkDisabled: ")
          .append(toIndentedString(networkDisabled))
          .append("\n");
        sb.append("    macAddress: ")
          .append(toIndentedString(macAddress))
          .append("\n");
        sb.append("    onBuild: ")
          .append(toIndentedString(onBuild))
          .append("\n");
        sb.append("    labels: ")
          .append(toIndentedString(labels))
          .append("\n");
        sb.append("    stopSignal: ")
          .append(toIndentedString(stopSignal))
          .append("\n");
        sb.append("    stopTimeout: ")
          .append(toIndentedString(stopTimeout))
          .append("\n");
        sb.append("    shell: ")
          .append(toIndentedString(shell))
          .append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private static String toIndentedString(java.lang.Object o)
    {
        if (o == null)
        {
            return "null";
        }
        return o.toString()
                .replace("\n", "\n    ");
    }
}
